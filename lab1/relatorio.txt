1) Faça um programa para criar dois processos, o pai escreve seu pid e espera o
filho terminar e o filho escreve o seu pid e termina.

Código:

#include <sys/types.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int mypid, pid, status;
    mypid = getpid();
    pid = fork();
    if (pid != 0)
    { // Pai
        printf("Meu PID (pai): %d\n", mypid);
        waitpid(-1, &status, 0);
    }
    else
    { // Filho
        mypid = getpid();
        printf("Meu PID (filho): %d\n", mypid);
    }
    return 0;
}

Saída:
Meu PID (pai): 466
Meu PID (filho): 467

Racional:
Como o esperado, o PID do pai é um número parcialmente imprevisível, mas o do filho é
justamente o seguinte ao PID do pai.


2) Agora, usando a mesma estrutura de processos pai e filho, declare uma
variável visível ao pai e ao filho, no pai inicialize a variável com1 e imprima seu
valor antes do fork(). No filho, altere o valor da variável para 5 e imprima o seu
valor antes do exit(). Agora, no pai, imprima novamente o valor da variável após o
filho ter alterado a variável - após a waitpid(). Justifique os resultados obtidos.

Código:
#include <sys/types.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int mypid, pid, status;

    int var = 1;

    printf("Antes: %d\n", var);

    pid = fork();
    if (pid != 0)
    { // Pai
        waitpid(-1, &status, 0);
        printf("Pai: %d\n", var);
    }
    else
    { // Filho
        var = 5;
        printf("Filho: %d\n", var);
        exit(0);
    }
    return 0;
}

Saída:
Antes: 1
Filho: 5
Pai: 1

Racional:
A variável quando aconteceu o fork foi duplicada no stack, o que criou então uma versão
para o pai e outra para o filho, o que faz com que a edição do filho não altere o que o pai
está vendo, resultando na não alteração da variável original.

3) Use o programa anterior para ler e ordenar um vetor de 10 posições. O filho
ordena o vetor e o pai exibe os dados do vetor antes do fork() e depois do
waitpid(). Eles usarão o mesmo vetor na memória? Justifique.

Código:
#include <sys/types.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>

void printa_vetor(char *palavra, int *vetor)
{
    printf("%s\n", palavra);
    for (int i = 0; i < 10; i++)
    {
        printf("%d, ", vetor[i]);
    };
    printf("\n");
}

int compara(const void *A, const void *B)
{
    int a = *((int *)A);
    int b = *((int *)B);

    if (a < b)
        return -1;
    else if (a > b)
        return 1;
    else
        return 0;
}

int main(void)
{
    int mypid, pid, status;

    int vetor[] = {1, 4, 5, 2, 8, 7, 3, 6, 10, 9};

    printa_vetor("Antes: ", vetor);

    pid = fork();
    if (pid != 0)
    { // Pai
        waitpid(-1, &status, 0);
        printa_vetor("Pai: ", vetor);
    }
    else
    { // Filho
        qsort(vetor, 10, sizeof(int), compara);
        printa_vetor("Filho: ", vetor);
        exit(0);
    }
    return 0;
}

Saída:
Antes: 
1, 4, 5, 2, 8, 7, 3, 6, 10, 9,
Filho:
1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
Pai:
1, 4, 5, 2, 8, 7, 3, 6, 10, 9,

Racional:
Como o vetor foi declarado estáticamente, ele existe na stack que então é duplicada
da mesma maneira que na anterior, tendo então uma versão para o pai e outra para o filho,
que esclarece o fato que o vetor não foi ordenado para o pai mesmo após o fim do processo
filho.

4) Modifique o programa anterior para que o filho execute um programa elaborado
por você, que mande imprimir uma mensagem qualquer no vídeo, por exemplo,
“alo mundo”. Em seguida altere o programa do item 4 para o filho executar o
programa echo da shell.

Código:
#include <sys/types.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>

void printa_vetor(char *palavra, int *vetor)
{
    printf("%s\n", palavra);
    for (int i = 0; i < 10; i++)
    {
        printf("%d, ", vetor[i]);
    };
    printf("\n");
}

int compara(const void *A, const void *B)
{
    int a = *((int *)A);
    int b = *((int *)B);

    if (a < b)
        return -1;
    else if (a > b)
        return 1;
    else
        return 0;
}

int main(void)
{
    int mypid, pid, status;

    int vetor[] = {1, 4, 5, 2, 8, 7, 3, 6, 10, 9};

    printa_vetor("Antes: ", vetor);

    pid = fork();
    if (pid != 0)
    { // Pai
        waitpid(-1, &status, 0);
        printa_vetor("Pai: ", vetor);
    }
    else
    { // Filho
        qsort(vetor, 10, sizeof(int), compara);
        execl("oi", NULL);
        char *argv[] = {"echo", "uau!", NULL};
        execvp("echo", argv);
        exit(0);
    }
    return 0;
}

Saída:
Antes: 
1, 4, 5, 2, 8, 7, 3, 6, 10, 9,
oi...
Pai:
1, 4, 5, 2, 8, 7, 3, 6, 10, 9,

Racional:
O programa funcionou como o esperado, e decidimos usar o execvp
para podermos fazer a chamada apenas com o nome "echo" que é
mais "limpo".