1) Execute o programa dado (exemplo de uso
de semáforos) e explique sua execução.

Código:
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/sem.h>
#include <sys/types.h>
#include <unistd.h>

union semun {
    int val;
    struct semid_ds *buf;
    ushort *array;
};

// inicializa o valor do semáforo
int setSemValue(int semId);
// remove o semáforo
void delSemValue(int semId);
// operação P
int semaforoP(int semId);
// operação V
int semaforoV(int semId);

int main(int argc, char *argv[])
{
    int i;
    char letra = 'o';
    int semId;
    if (argc > 1)
    {
        semId = semget(8752, 1, 0666 | IPC_CREAT);
        setSemValue(semId);
        letra = 'x';
        sleep(2);
    }
    else
    {
        while ((semId = semget(8752, 1, 0666)) < 0)
        {
            putchar('.');
            fflush(stdout);
            sleep(1);
        }
    }
    for (i = 0; i < 10; i++)
    {
        semaforoP(semId);
        putchar(toupper(letra));
        fflush(stdout);
        sleep(rand() % 3);
        putchar(letra);
        fflush(stdout);
        semaforoV(semId);
        sleep(rand() % 2);
    }
    printf("\nProcesso %d terminou\n", getpid());
    if (argc > 1)
    {
        sleep(10);
        delSemValue(semId);
    }
    return 0;
}

int setSemValue(int semId)
{
    union semun semUnion;
    semUnion.val = 1;
    return semctl(semId, 0, SETVAL, semUnion);
}
void delSemValue(int semId)
{
    union semun semUnion;
    semctl(semId, 0, IPC_RMID, semUnion);
}
int semaforoP(int semId)
{
    struct sembuf semB;
    semB.sem_num = 0;
    semB.sem_op = -1;
    semB.sem_flg = SEM_UNDO;
    semop(semId, &semB, 1);
    return 0;
}
int semaforoV(int semId)
{
    struct sembuf semB;
    semB.sem_num = 0;
    semB.sem_op = 1;
    semB.sem_flg = SEM_UNDO;
    semop(semId, &semB, 1);
    return 0;
}


Comando:
gcc lab7/ex1.c -o build/ex1

./build/ex1 &
./build/ex1 1



Saída:
[1] 285200
.OoXxOoXxOoXxOoXxOoXxOoXxOoXxOoXxOoXxOoX
Processo 285200 terminou
x
Processo 285201 terminou
[1]+  Done                    ./build/ex1


Racional:
Os processos alternam, cada um escrevendo a sua letra no terminal, primeiro a versão maiúscula da letra e depois a minúscula.
Entre as versões da letra, o processo dorme por um tempo aleatório. Nesse intervalo, o outro processo pode tentar também
entrar na região crítica. Entretanto, o processo ficará bloqueado na linha "semaforoP(semId);", porque o semáforo já está em 0
e portanto não pode ser decrementado novamente. Quando o processo que estava na região crítica sai, imprime a versão minúscula
de sua letra e libera o outro processo, que agora pode entrar na região crítica e imprimir versão maiúscula da sua letra.
Esse padrão de funcionamento é manifestado pelo padrão das letras na saída: sempre vemos uma letra maiúscula seguida,
logo após, pela versão minúscula da própria letra.


2) Produtor-Consumidor
- Escreva um programa formado por dois
processos concorrentes, leitor e impressor, que
usam memória compartilhada executando um
loop infinito. Para sincronizar as suas ações, eles
fazem uso de semáforos.
- O processo leitor fica lendo caracteres da entrada
padrão e colocando em um buffer de 16 posições.
Quando o buffer está cheio o processo impressor
deve imprimi-lo na saída padrão.


Código:

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <unistd.h>

#define SHMEM_KEY 66421
#define IMPRESSOR_SEM_KEY 8753
#define LEITOR_SEM_KEY 8754
#define BUFFER_SIZE 16

union semun {
    int val;
    struct semid_ds *buf;
    unsigned short *array;
};

int semIdLeitor;
int semIdImpressor;

int setSemImpressorValue(int semId)
{
    union semun semUnion;
    semUnion.val = 1 - BUFFER_SIZE;
    return semctl(semId, 0, SETVAL, semUnion);
}

int setSemLeitorValue(int semId)
{
    union semun semUnion;
    semUnion.val = BUFFER_SIZE;
    return semctl(semId, 0, SETVAL, semUnion);
}

void delSemValue(int semId)
{
    union semun semUnion;
    semctl(semId, 0, IPC_RMID, semUnion);
}
int semaforoPLeitor(int semId)
{
    struct sembuf semB;
    semB.sem_num = 0;
    semB.sem_op = -1;
    semB.sem_flg = SEM_UNDO;
    semop(semId, &semB, 1);
    return 0;
}

int semaforoPImpressor(int semId)
{
    struct sembuf semB;
    semB.sem_num = 0;
    semB.sem_op = -BUFFER_SIZE;
    semB.sem_flg = SEM_UNDO;
    semop(semId, &semB, 1);
    return 0;
}

int semaforoVLeitor(int semId)
{
    struct sembuf semB;
    semB.sem_num = 0;
    semB.sem_op = BUFFER_SIZE;
    semB.sem_flg = SEM_UNDO;
    semop(semId, &semB, 1);
    return 0;
}

int semaforoVImpressor(int semId)
{
    struct sembuf semB;
    semB.sem_num = 0;
    semB.sem_op = 1;
    semB.sem_flg = SEM_UNDO;
    semop(semId, &semB, 1);
    return 0;
}

void intHandler(int signal)
{
    printf("Vou parar, espera um tiquinho...\n");

    sleep(5);

    delSemValue(semIdLeitor);
    delSemValue(semIdImpressor);

    exit(0);
}

int main(int argc, char *argv[])
{
    char buffer_for_size[BUFFER_SIZE];

    char *buffer;

    int shmid = shmget(SHMEM_KEY, sizeof(buffer_for_size),
                       IPC_CREAT | S_IRUSR | S_IWUSR | S_IXUSR | S_IROTH | S_IWOTH | S_IXOTH);

    if (shmid < 0)
    {
        perror("Não consegui pegar shmem.");
        exit(EXIT_FAILURE);
    }

    buffer = (char *)shmat(shmid, 0, 0);

    for (int i = 0; i < BUFFER_SIZE; i++)
    {
        buffer[i] = -1;
    }

    semIdImpressor = semget(IMPRESSOR_SEM_KEY, 1, 0666 | IPC_CREAT);

    setSemImpressorValue(semIdImpressor);

    semIdLeitor = semget(LEITOR_SEM_KEY, 1, 0666 | IPC_CREAT);

    setSemLeitorValue(semIdLeitor);

    if (fork() == 0)
    { // Impressor

        sleep(2);

        printf("Impressor: vou começar\n");

        while (1)
        {
            semaforoPImpressor(semIdImpressor);
            printf("Impressor: opa, buffer cheio!\n");

            for (int i = 0; i < BUFFER_SIZE; i++)
            {
                putchar(buffer[i]);
                fflush(stdout);
                buffer[i] = -1;
            }
            printf("\n");
            printf("Impressor: resetei buffer e imprimi\n");

            semaforoVLeitor(semIdLeitor);
        }
    }
    else
    { // Leitor
        signal(SIGINT, intHandler);

        char my_char;

        while (1)
        {
            semaforoPLeitor(semIdLeitor);

            printf("Leitor: vou ler caracter agora...\n");

            while ((my_char = getchar()) == 10) // pular enter
                ;
            printf("Leitor: li '%c' (%d)\n", my_char, my_char);

            for (int i = 0; i < BUFFER_SIZE; i++)
            {
                if (buffer[i] == -1)
                {
                    buffer[i] = my_char;
                    printf("Leitor: achei espaço vazio em %d, botei '%c' (%d) nele\n", i, my_char, my_char);
                    break;
                }
                else if (i == BUFFER_SIZE - 1)
                {
                    printf("Leitor: não achei espaço vazio!!! Não era pra acontecer! Estou com caracter '%c'\n",
                           my_char);
                }
            }

            semaforoVImpressor(semIdImpressor);
        }
    }

    return 0;
}



Comando:

gcc lab7/ex2.c -o build/ex2

./build/ex2


Saída:

Leitor: vou ler caracter agora...
Impressor: vou começar
e
Leitor: li 'e' (101)
Leitor: achei espaço vazio em 0, botei 'e' (101) nele
Leitor: vou ler caracter agora...
n
Leitor: li 'n' (110)
Leitor: achei espaço vazio em 1, botei 'n' (110) nele
Leitor: vou ler caracter agora...
d
Leitor: li 'd' (100)
Leitor: achei espaço vazio em 2, botei 'd' (100) nele
Leitor: vou ler caracter agora...
l
Leitor: li 'l' (108)
Leitor: achei espaço vazio em 3, botei 'l' (108) nele
Leitor: vou ler caracter agora...
e
Leitor: li 'e' (101)
Leitor: achei espaço vazio em 4, botei 'e' (101) nele
Leitor: vou ler caracter agora...
r
Leitor: li 'r' (114)
Leitor: achei espaço vazio em 5, botei 'r' (114) nele
Leitor: vou ler caracter agora...
e
Leitor: li 'e' (101)
Leitor: achei espaço vazio em 6, botei 'e' (101) nele
Leitor: vou ler caracter agora...
p
Leitor: li 'p' (112)
Leitor: achei espaço vazio em 7, botei 'p' (112) nele
Leitor: vou ler caracter agora...
e
Leitor: li 'e' (101)
Leitor: achei espaço vazio em 8, botei 'e' (101) nele
Leitor: vou ler caracter agora...
d
Leitor: li 'd' (100)
Leitor: achei espaço vazio em 9, botei 'd' (100) nele
Leitor: vou ler caracter agora...
r
Leitor: li 'r' (114)
Leitor: achei espaço vazio em 10, botei 'r' (114) nele
Leitor: vou ler caracter agora...
o
Leitor: li 'o' (111)
Leitor: achei espaço vazio em 11, botei 'o' (111) nele
Leitor: vou ler caracter agora...
b
Leitor: li 'b' (98)
Leitor: achei espaço vazio em 12, botei 'b' (98) nele
Leitor: vou ler caracter agora...
a
Leitor: li 'a' (97)
Leitor: achei espaço vazio em 13, botei 'a' (97) nele
Leitor: vou ler caracter agora...
r
Leitor: li 'r' (114)
Leitor: achei espaço vazio em 14, botei 'r' (114) nele
Leitor: vou ler caracter agora...
e
Leitor: li 'e' (101)
Leitor: achei espaço vazio em 15, botei 'e' (101) nele
Impressor: opa, buffer cheio!
endlerepedrobare
Impressor: resetei buffer e imprimi
Leitor: vou ler caracter agora...
l
Leitor: li 'l' (108)
Leitor: achei espaço vazio em 0, botei 'l' (108) nele
Leitor: vou ler caracter agora...
a
Leitor: li 'a' (97)
Leitor: achei espaço vazio em 1, botei 'a' (97) nele
Leitor: vou ler caracter agora...
^CVou parar, espera um tiquinho...


Racional:
Após digitar os caracteres "endlerepedrobare", alternando com a tecla enter para enviar, percebemos que o processo leitor corretamente
lê cada caracter, salvando-o no buffer na posição indicada. Ele procura o primeiro espaço livre (que tem o valor -1) no buffer e insere
o novo caracter ali. Depois, quando o buffer atinge 16 caracteres (a posição 15 acabou de ser preenchida), o processo impressor é
acordado e executa, escrevendo os caracteres na saída e limpando o buffer.
Os semáforos coordenam toda a alternância entre leitor e impressor. Usamos 2 semáforos, um para bloquear o leitor quando o buffer
está cheio e outro para bloquear o impressor quando o buffer não está cheio (liberando-o quando fica cheio). Assim, foi necessário
inicializar o semáforo do leitor em BUFFER_SIZE, de forma que, quando todos os caracteres tenham sido lidos, ele alcance 0, bloqueando
o leitor. Já o semáforo do impressor foi inicializado em 1 - BUFFER_SIZE, um número geralmente negativo, de forma que, quando o buffer estiver
cheio, ele assuma o valor de 1, liberando o impressor (que fará uma operação P para jogar o valor do semáforo de volta para 1 - BUFFER_SIZE). 



3) Faça programas para alterar um valor de
uma variável na memória compartilhada.
Um programa soma 1 à variável e o outro
soma 5 à variável. Utilize semáforos para
alterar a variável (região crítica).

Código:

// ex3_a.c

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <unistd.h>

#define SHMEM_KEY 66421
#define SEM_KEY 8752
#define BUFFER_SIZE 16
#define VALOR_SOMA 1

union semun {
    int val;
    struct semid_ds *buf;
    unsigned short *array;
};

int semId;

// inicializa o valor do semáforo
int setSemValue(int semId);
// remove o semáforo
void delSemValue(int semId);
// operação P
int semaforoP(int semId);
// operação V
int semaforoV(int semId);

void intHandler(int signal)
{
    printf("Vou parar, espera um tiquinho...\n");

    sleep(5);

    delSemValue(semId);

    exit(0);
}

int main(int argc, char *argv[])
{
    long *var;

    int shmid = shmget(SHMEM_KEY, sizeof(var), IPC_CREAT | S_IRUSR | S_IWUSR | S_IXUSR | S_IROTH | S_IWOTH | S_IXOTH);

    if (shmid < 0)
    {
        perror("Não consegui pegar shmem.");
        exit(EXIT_FAILURE);
    }

    var = (long *)shmat(shmid, 0, 0);

    *var = 0;

    if (fork() == 0)
    { // Programa B
        char *argv[] = {"ex3_b", NULL};
        execv("./build/ex3_b", argv);
        perror("Não consegui dar execv.");
        exit(EXIT_FAILURE);
    }
    else
    { // Programa A
        signal(SIGINT, intHandler);

        while ((semId = semget(SEM_KEY, 1, 0666)) < 0)
        {
            putchar('.');
            fflush(stdout);
            sleep(1);
        }

        while (1)
        {
            printf("A: vou pegar semáforo...\n");
            semaforoP(semId);
            printf("A: peguei semáforo!\n");

            printf("A: o valor tá em %ld...\n", *var);
            *var += VALOR_SOMA;
            printf("A: e foi pra %ld\n", *var);

            printf("A: indo dormir com semáforo...\n");
            sleep(rand() % 3);

            printf("A: vou devolver semáforo...\n");
            semaforoV(semId);

            printf("A: indo dormir sem semáforo...\n");
            sleep(rand() % 2);
        }
    }

    return 0;
}

int setSemValue(int semId)
{
    union semun semUnion;
    semUnion.val = 1;
    return semctl(semId, 0, SETVAL, semUnion);
}
void delSemValue(int semId)
{
    union semun semUnion;
    semctl(semId, 0, IPC_RMID, semUnion);
}
int semaforoP(int semId)
{
    struct sembuf semB;
    semB.sem_num = 0;
    semB.sem_op = -1;
    semB.sem_flg = SEM_UNDO;
    semop(semId, &semB, 1);
    return 0;
}
int semaforoV(int semId)
{
    struct sembuf semB;
    semB.sem_num = 0;
    semB.sem_op = 1;
    semB.sem_flg = SEM_UNDO;
    semop(semId, &semB, 1);
    return 0;
}

// ex3_b.c

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <unistd.h>

#define SHMEM_KEY 66421
#define SEM_KEY 8752
#define BUFFER_SIZE 16
#define VALOR_SOMA 5

union semun {
    int val;
    struct semid_ds *buf;
    unsigned short *array;
};

int semId;

// inicializa o valor do semáforo
int setSemValue(int semId);
// remove o semáforo
void delSemValue(int semId);
// operação P
int semaforoP(int semId);
// operação V
int semaforoV(int semId);

void intHandler(int signal)
{
    printf("Vou parar, espera um tiquinho...\n");

    sleep(5);

    delSemValue(semId);

    exit(0);
}

int main(int argc, char *argv[])
{
    long *var;

    int shmid = shmget(SHMEM_KEY, sizeof(var), IPC_CREAT | S_IRUSR | S_IWUSR | S_IXUSR | S_IROTH | S_IWOTH | S_IXOTH);

    if (shmid < 0)
    {
        perror("Não consegui pegar shmem.");
        exit(EXIT_FAILURE);
    }

    var = (long *)shmat(shmid, 0, 0);

    semId = semget(SEM_KEY, 1, 0666 | IPC_CREAT);

    setSemValue(semId);

    while (1)
    {
        printf("B: vou pegar semáforo...\n");
        semaforoP(semId);
        printf("B: peguei semáforo!\n");

        printf("B: o valor tá em %ld...\n", *var);
        *var += VALOR_SOMA;
        printf("B: e foi pra %ld\n", *var);

        printf("B: indo dormir com semáforo...\n");
        sleep(rand() % 3);

        printf("B: vou devolver semáforo...\n");
        semaforoV(semId);

        printf("B: indo dormir sem semáforo...\n");
        sleep(rand() % 2);
    }

    return 0;
}

int setSemValue(int semId)
{
    union semun semUnion;
    semUnion.val = 1;
    return semctl(semId, 0, SETVAL, semUnion);
}
void delSemValue(int semId)
{
    union semun semUnion;
    semctl(semId, 0, IPC_RMID, semUnion);
}
int semaforoP(int semId)
{
    struct sembuf semB;
    semB.sem_num = 0;
    semB.sem_op = -1;
    semB.sem_flg = SEM_UNDO;
    semop(semId, &semB, 1);
    return 0;
}
int semaforoV(int semId)
{
    struct sembuf semB;
    semB.sem_num = 0;
    semB.sem_op = 1;
    semB.sem_flg = SEM_UNDO;
    semop(semId, &semB, 1);
    return 0;
}


Comando:

gcc -Wall ./lab7/ex3_a.c -o build/ex3_a
gcc -Wall ./lab7/ex3_b.c -o build/ex3_b

./build/ex3_a


Saída:

.B: vou pegar semáforo...
B: peguei semáforo!
B: o valor tá em 0...
B: e foi pra 5
B: indo dormir com semáforo...
A: vou pegar semáforo...
B: vou devolver semáforo...
B: indo dormir sem semáforo...
A: peguei semáforo!
B: vou pegar semáforo...
A: o valor tá em 5...
A: e foi pra 6
A: indo dormir com semáforo...
A: vou devolver semáforo...
A: indo dormir sem semáforo...
B: peguei semáforo!
B: o valor tá em 6...
B: e foi pra 11
B: indo dormir com semáforo...
A: vou pegar semáforo...
B: vou devolver semáforo...
B: indo dormir sem semáforo...
A: peguei semáforo!
A: o valor tá em 11...
A: e foi pra 12
A: indo dormir com semáforo...
A: vou devolver semáforo...
A: indo dormir sem semáforo...
B: vou pegar semáforo...
B: peguei semáforo!
B: o valor tá em 12...
B: e foi pra 17
B: indo dormir com semáforo...
A: vou pegar semáforo...
B: vou devolver semáforo...
B: indo dormir sem semáforo...
A: peguei semáforo!
A: o valor tá em 17...
A: e foi pra 18
A: indo dormir com semáforo...
B: vou pegar semáforo...
A: vou devolver semáforo...
A: indo dormir sem semáforo...
B: peguei semáforo!
B: o valor tá em 18...
B: e foi pra 23
B: indo dormir com semáforo...
A: vou pegar semáforo...
B: vou devolver semáforo...
B: indo dormir sem semáforo...
A: peguei semáforo!
A: o valor tá em 23...
A: e foi pra 24
B: vou pegar semáforo...
A: indo dormir com semáforo...
A: vou devolver semáforo...
A: indo dormir sem semáforo...
B: peguei semáforo!
B: o valor tá em 24...
B: e foi pra 29
B: indo dormir com semáforo...
A: vou pegar semáforo...
B: vou devolver semáforo...
B: indo dormir sem semáforo...
A: peguei semáforo!
A: o valor tá em 29...
A: e foi pra 30
A: indo dormir com semáforo...
A: vou devolver semáforo...
A: indo dormir sem semáforo...
B: vou pegar semáforo...
B: peguei semáforo!
A: vou pegar semáforo...
B: o valor tá em 30...
B: e foi pra 35
B: indo dormir com semáforo...
B: vou devolver semáforo...
B: indo dormir sem semáforo...
A: peguei semáforo!
A: o valor tá em 35...
A: e foi pra 36
A: indo dormir com semáforo...
B: vou pegar semáforo...
^CVou parar, espera um tiquinho...


Racional:

O semáforo impede que ocorram problemas de concorrência ao alterar a variável compartilhada. Quando um processo vai entrar na região crítica, ele
coloca o semáforo em 0. Quando o outro chega na região crítica e o semáforo já possui valor 0, ele é forçado a esperar
o outro processo incrementar o semáforo.
Vemos pela saída que os incrementos da variável são atômicos. Nenhum dos processos altera a variável enquanto o outro está na região crítica.
A chamada a sleep que existe dentro da região crítica (simulando uma operação demorada) nos confirma que, por exemplo, o processo A
pode "segurar" o semáforo por bastante
tempo (dormindo), mas o processo B fica travado na linha de "vou pegar semáforo" até que o processo A passe pela linha de "vou devolver semáforo".

4) Faça programas separados que utilizam a
memória compartilhada para trocar
mensagens. Utilize semáforos para
sincronizar a aplicação.

Código:

// ex4_a.c

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <unistd.h>
#include <time.h>
#include <errno.h>

#define SHMEM_KEY 66421
#define SEM_KEY 8752
#define BUFFER_SIZE 64
#define A_EMPTY 0
#define A_FULL 1
#define B_EMPTY 2
#define B_FULL 3
#define NUM_SEMS 4
#define MESSAGE_SIZE (BUFFER_SIZE / 2)

union semun {
    int val;
    struct semid_ds *buf;
    unsigned short *array;
};

int semId;

char* sendBuffer;
char* receiveBuffer;

// inicializa o valor do semáforo
int setSemValue(int semId, int semNum, int value);
// remove o semáforo
void delSemValue(int semId);
// operação P
int semaforoP(int semId, int semNum);
// operação V
int semaforoV(int semId, int semNum);

char* sendMessage();

char* receiveMessage();

int raiseProgramB()
{
    if (fork() == 0)
    { // Programa B
        char *argv[] = {"ex4_b", NULL};
        execv("./build/ex4_b", argv);
        perror("Não consegui dar execv.");
        exit(EXIT_FAILURE);
    }
    return 0;
}

int programARoutine()
{
    printf("Programa A iniciado.\n");
    semId = semget(SEM_KEY, NUM_SEMS, 0666 | IPC_CREAT);
    if (semId < 0)
    {
        perror("Não consegui criar semáforo.");
        exit(EXIT_FAILURE);
    }

    setSemValue(semId, A_EMPTY, 1);
    setSemValue(semId, A_FULL, 0);
    setSemValue(semId, B_EMPTY, 1);
    setSemValue(semId, B_FULL, 0);

    printf("A: Semáforos inicializados.\n");

    printf("A: Iniciando rotina...\n");
    int nadaFeito = 1;
    while (1)
    {
        if (nadaFeito) {
            printf("A: Nada a fazer, vou dormir...\n");
            sleep(1);
        }

        printf("A: Tentando receber mensagem...\n");
        if (semaforoP(semId, A_FULL) == 0) {
            char* message = receiveMessage();
            printf("A: Mensagem recebida: %s\n", message);
            semaforoV(semId, A_EMPTY);
            nadaFeito = 0;
        } else {
            printf("A: Não consegui receber mensagem.\n");
            nadaFeito = 1;
        }

        printf("A: Tentando enviar mensagem...\n");
        if (semaforoP(semId, B_EMPTY) == 0) {
            char* message = sendMessage();
            printf("A: Enviando mensagem: %s\n", message);
            semaforoV(semId, B_FULL);
            nadaFeito = 0;
        } else {
            printf("A: Não consegui enviar mensagem.\n");
            nadaFeito = 1;
        }

        sleep(1);
    }

    return 0;
}

void intHandler(int signal)
{
    printf("Vou parar, espera um tiquinho...\n");

    sleep(5);

    delSemValue(semId);
    shmdt(sendBuffer);

    exit(0);
}

int main(int argc, char *argv[])
{
    srand((unsigned int)time(NULL));
    signal(SIGINT, intHandler);

    int shmid = shmget(SHMEM_KEY, BUFFER_SIZE, IPC_CREAT | S_IRUSR | S_IWUSR | S_IXUSR | S_IROTH | S_IWOTH | S_IXOTH);

    if (shmid < 0)
    {
        perror("Não consegui pegar shmem.");
        exit(EXIT_FAILURE);
    }

    sendBuffer = (char*) shmat(shmid, 0, 0);
    receiveBuffer = sendBuffer + (MESSAGE_SIZE);

    raiseProgramB();
    
    programARoutine();

    return 0;
}



int setSemValue(int semId, int semNum, int value)
{
    union semun semUnion;
    semUnion.val = value;
    return semctl(semId, semNum, SETVAL, semUnion);
}

void delSemValue(int semId)
{
    union semun semUnion;
    semctl(semId, 0, IPC_RMID, semUnion);
}

int semaforoP(int semId, int semNum)
{
    struct sembuf semB;
    semB.sem_num = semNum;
    semB.sem_op = -1;
    semB.sem_flg = SEM_UNDO | IPC_NOWAIT;
    if (semop(semId, &semB, 1) == -1) {
        if (errno != EAGAIN) {
            perror("semop P failed");
            exit(EXIT_FAILURE);
        }
        return -1;
    }
    return 0;
}

int semaforoV(int semId, int semNum)
{
    struct sembuf semB;
    semB.sem_num = semNum;
    semB.sem_op = 1;
    semB.sem_flg = SEM_UNDO;
    return semop(semId, &semB, 1);
}

char* randomMessage() {
    static const char alphanum[] =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz"
        "0123456789";
    static char message[MESSAGE_SIZE + 1];

    for (int i = 0; i < MESSAGE_SIZE; ++i) {
        message[i] = alphanum[rand() % (sizeof(alphanum) - 1)];
    }
    message[MESSAGE_SIZE] = '\0';
    return message;
}

char* sendMessage() {
    char* message = randomMessage();

    for (int i = 0; i < MESSAGE_SIZE; i++) {
        sendBuffer[i] = message[i];
    }
    return message;
}

char* receiveMessage() {
    static char message[MESSAGE_SIZE + 1];
    for (int i = 0; i < MESSAGE_SIZE; i++) {
        message[i] = receiveBuffer[i];
    }
    message[MESSAGE_SIZE] = '\0';
    return message;
}

// ex4_b.c

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <unistd.h>
#include <time.h>
#include <errno.h>

#define SHMEM_KEY 66421
#define SEM_KEY 8752
#define BUFFER_SIZE 64
#define A_EMPTY 0
#define A_FULL 1
#define B_EMPTY 2
#define B_FULL 3
#define NUM_SEMS 4
#define MESSAGE_SIZE (BUFFER_SIZE / 2)

union semun {
    int val;
    struct semid_ds *buf;
    unsigned short *array;
};

int semId;

char* sendBuffer;
char* receiveBuffer;

// inicializa o valor do semáforo
int setSemValue(int semId, int semNum, int value);
// remove o semáforo
void delSemValue(int semId);
// operação P
int semaforoP(int semId, int semNum);
// operação V
int semaforoV(int semId, int semNum);

char* sendMessage();

char* receiveMessage();

int programBRoutine() {
    printf("Programa B iniciado.\n");
    printf("B: esperando configuração de semáforos...\n");
    sleep(2); // espera o programa A configurar os semáforos

    printf("B: tentando conectar semáforos.");
    while ((semId = semget(SEM_KEY, NUM_SEMS, 0666)) < 0) {
        putchar('.');
        fflush(stdout);
        sleep(1);
    }
    printf("\nB: Semáforos conectados.\n");

    printf("Programa B: Iniciando rotina...\n");
    int nadaFeito = 1;
    while (1) {
        if (nadaFeito) {
            printf("B: Nada feito, vou esperar um pouco...\n");
            sleep(2);
        }

        printf("B: Tentando receber mensagem...\n");
        if (semaforoP(semId, B_FULL) == 0) {
            char* message = receiveMessage();
            printf("B: Mensagem recebida: %s\n", message);
            semaforoV(semId, B_EMPTY);
            nadaFeito = 0;
        } else {
            printf("B: Não consegui receber mensagem.\n");
            nadaFeito = 1;
        }

        printf("B: Tentando enviar mensagem...\n");
        if (semaforoP(semId, A_EMPTY) == 0) {
            char* message = sendMessage();
            printf("B: Mensagem enviada: %s\n", message);
            semaforoV(semId, A_FULL);
            nadaFeito = 0;
        } else {
            printf("B: Não consegui enviar mensagem.\n");
            nadaFeito = 1;
        }

        sleep(1);
    }

    return 0;
}

void intHandler(int signal)
{
    printf("Vou parar, espera um tiquinho...\n");

    sleep(5);

    delSemValue(semId);

    exit(0);
}

int main(int argc, char *argv[])
{
    srand((unsigned int)time(NULL) + 587342);
    signal(SIGINT, intHandler);

    int shmid = shmget(SHMEM_KEY, BUFFER_SIZE, IPC_CREAT | S_IRUSR | S_IWUSR | S_IXUSR | S_IROTH | S_IWOTH | S_IXOTH);

    if (shmid < 0)
    {
        perror("Não consegui pegar shmem.");
        exit(EXIT_FAILURE);
    }

    receiveBuffer = (char *)shmat(shmid, 0, 0);
    sendBuffer = receiveBuffer + (MESSAGE_SIZE);

    programBRoutine();

    return 0;
}



int setSemValue(int semId, int semNum, int value)
{
    union semun semUnion;
    semUnion.val = value;
    return semctl(semId, semNum, SETVAL, semUnion);
}

void delSemValue(int semId)
{
    union semun semUnion;
    semctl(semId, 0, IPC_RMID, semUnion);
}

int semaforoP(int semId, int semNum)
{
    struct sembuf semB;
    semB.sem_num = semNum;
    semB.sem_op = -1;
    semB.sem_flg = SEM_UNDO | IPC_NOWAIT;
    if (semop(semId, &semB, 1) == -1) {
        if (errno != EAGAIN) {
            perror("semop P failed");
            exit(EXIT_FAILURE);
        }
        return -1;
    }
    return 0;
}

int semaforoV(int semId, int semNum)
{
    struct sembuf semB;
    semB.sem_num = semNum;
    semB.sem_op = 1;
    semB.sem_flg = SEM_UNDO;
    return semop(semId, &semB, 1);
}

char* randomMessage() {
    static const char alphanum[] =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz"
        "0123456789";
    static char message[MESSAGE_SIZE + 1];

    for (int i = 0; i < MESSAGE_SIZE; ++i) {
        message[i] = alphanum[rand() % (sizeof(alphanum) - 1)];
    }
    message[MESSAGE_SIZE] = '\0';
    return message;
}

char* sendMessage() {
    char* message = randomMessage();

    for (int i = 0; i < MESSAGE_SIZE; i++) {
        sendBuffer[i] = message[i];
    }
    return message;
}

char* receiveMessage() {
    static char message[MESSAGE_SIZE + 1];
    for (int i = 0; i < MESSAGE_SIZE; i++) {
        message[i] = receiveBuffer[i];
    }
    message[MESSAGE_SIZE] = '\0';
    return message;
}

Comando:

gcc -Wall ./lab7/ex4_a.c -o build/ex4_a
gcc -Wall ./lab7/ex4_b.c -o build/ex4_b

./build/ex4_a

Saída:

Programa A iniciado.
A: Semáforos inicializados.
A: Iniciando rotina...
A: Nada a fazer, vou dormir...
Programa B iniciado.
B: esperando configuração de semáforos...
A: Tentando receber mensagem...
A: Não consegui receber mensagem.
A: Tentando enviar mensagem...
A: Enviando mensagem: PQhlNAA4qGBx8v6k6LX6aMP0ipoNouF4
A: Tentando receber mensagem...
A: Não consegui receber mensagem.
A: Tentando enviar mensagem...
A: Não consegui enviar mensagem.
B: tentando conectar semáforos.
B: Semáforos conectados.
Programa B: Iniciando rotina...
B: Nada feito, vou esperar um pouco...
A: Nada a fazer, vou dormir...
A: Tentando receber mensagem...
A: Não consegui receber mensagem.
A: Tentando enviar mensagem...
A: Não consegui enviar mensagem.
B: Tentando receber mensagem...
B: Mensagem recebida: PQhlNAA4qGBx8v6k6LX6aMP0ipoNouF4
B: Tentando enviar mensagem...
B: Mensagem enviada: rEFoTftXJBa5JCGbhwhaqZ3M6vzBtQ6Y
A: Nada a fazer, vou dormir...
B: Tentando receber mensagem...
B: Não consegui receber mensagem.
B: Tentando enviar mensagem...
B: Não consegui enviar mensagem.
A: Tentando receber mensagem...
A: Mensagem recebida: rEFoTftXJBa5JCGbhwhaqZ3M6vzBtQ6Y
A: Tentando enviar mensagem...
A: Enviando mensagem: BkdMidFPiGAgz7EtIbnio2WMfBZKvcCu
B: Nada feito, vou esperar um pouco...
A: Tentando receber mensagem...
A: Não consegui receber mensagem.
A: Tentando enviar mensagem...
A: Não consegui enviar mensagem.
A: Nada a fazer, vou dormir...
B: Tentando receber mensagem...
B: Mensagem recebida: BkdMidFPiGAgz7EtIbnio2WMfBZKvcCu
B: Tentando enviar mensagem...
B: Mensagem enviada: UBCoeu9ntZh2bnR6ZyWDOQNIBAJsQFGj
A: Tentando receber mensagem...
A: Mensagem recebida: UBCoeu9ntZh2bnR6ZyWDOQNIBAJsQFGj
A: Tentando enviar mensagem...
A: Enviando mensagem: Cf5k6AxeEy94vDl1fPZJFtTlsqvcIvMI
B: Tentando receber mensagem...
B: Mensagem recebida: Cf5k6AxeEy94vDl1fPZJFtTlsqvcIvMI
B: Tentando enviar mensagem...
B: Mensagem enviada: EGNj0MKjjrb9Vq5sfSwri7zh86NOCRvG
A: Tentando receber mensagem...
A: Mensagem recebida: EGNj0MKjjrb9Vq5sfSwri7zh86NOCRvG
A: Tentando enviar mensagem...
A: Enviando mensagem: QFsMFgrISqADrl4M0RT6AkfrQQJW9TeP
B: Tentando receber mensagem...
B: Mensagem recebida: QFsMFgrISqADrl4M0RT6AkfrQQJW9TeP
B: Tentando enviar mensagem...
B: Mensagem enviada: X8pOIyxqfNpy1khW0RBWOy1MvCZxTK1p
A: Tentando receber mensagem...
A: Mensagem recebida: X8pOIyxqfNpy1khW0RBWOy1MvCZxTK1p
A: Tentando enviar mensagem...
A: Enviando mensagem: ZLZcpEk7skAaK2kAJ24HcZytn7FmRkzq
B: Tentando receber mensagem...
B: Mensagem recebida: ZLZcpEk7skAaK2kAJ24HcZytn7FmRkzq
B: Tentando enviar mensagem...
B: Mensagem enviada: Hf1NTm3wxgjpFEB5VBShzHsiKFTdNLGU
A: Tentando receber mensagem...
A: Mensagem recebida: Hf1NTm3wxgjpFEB5VBShzHsiKFTdNLGU
A: Tentando enviar mensagem...
A: Enviando mensagem: tPGYRrVAPTaZL8YU0SZTqMARJF2YnrCW
B: Tentando receber mensagem...
B: Mensagem recebida: tPGYRrVAPTaZL8YU0SZTqMARJF2YnrCW
B: Tentando enviar mensagem...
B: Mensagem enviada: o7g5kXrX4QC9SC2lBKJ0Q1Xa4q1Hz8cd
^CVou parar, espera um tiquinho...
Vou parar, espera um tiquinho...

Racional:

Para este programa decidimos usar o busy wait para evitar a condição
de deadlock onde ambos os programas poderiam ficar esperando o outro
enviar alguma mensagem, forçando então a usarmos busy wait. Foi considerado
o uso do select, mas semáforos do tipo sysV não podem ser usados desta
maneira, então a solução final usa o busy wait para que o envio e a
recepção de mensagens possam ser independentes entre si. Foram utilizados
uma região de memória particionada em duas, uma para cada lado da 
comunicação, e 4 semáforos, para indicar quando se pode preencher ou ler
para ambos os lados.