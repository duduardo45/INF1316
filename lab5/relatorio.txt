1) Abra duas seções de terminais
- Na primeira, execute um programa que fica em
loop lendo de uma FIFO para depois escrever na
saída padrão (tela)
- Na segunda, execute um programa que fica lendo
da entrada padrão (teclado) e depois escreve na
mesma FIFO


Código:

// ex1_leitor.c

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <fcntl.h>

int main(int argc, char *argv[])
{
    int fifo = open("ex1_fifo", O_WRONLY);
    char texto_lido[101];
    while (1)
    {
        int scanned = scanf(" %[^\n]100s", texto_lido);
        printf("Li\n");
        if (scanned < 0)
        {
            perror("erro ao escanear");
        }
        write(fifo, texto_lido, sizeof(texto_lido));
        printf("Escrevi no fifo\n");
    }

    return 0;
}

// ex1_escritor.c

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <fcntl.h>

int main(int argc, char *argv[])
{
    int fifo = open("ex1_fifo", O_RDONLY);
    char texto_pra_escrever[101];
    while (1)
    {
        int fifo_read = read(fifo, texto_pra_escrever, sizeof(texto_pra_escrever));
        if (fifo_read < 0)
        {
            perror("Erro lendo do fifo");
        }
        printf("%s\n", texto_pra_escrever);
    }

    return 0;
}

Comando:
mkfifo ex1_fifo
gcc lab5/ex1_escritor.c -o build/ex1_escritor
gcc lab5/ex1_leitor.c -o build/ex1_leitor

# em dois terminais diferentes:
./build/ex1_leitor

./build/ex1_escritor

# escrever "Oi monitor!" no terminal do ex1_leitor e teclar "enter"

Saída (no ex1_leitor):
Oi monitor!    
Li
Escrevi no fifo

Saída (no ex1_escritor):
Oi monitor!


Racional:
Uso padrão do fifo. Decidi criar o fifo por fora do programa e só usá-lo dentro. Ambos os processos somente
se conectam ao fifo. Depois, entram em um loop infinito. Um deles lê do teclado e escreve no fifo. O outro
lê do fifo tudo aquilo que o outro escreveu, e escreve na tela. O que lê do fifo fica bloqueado no comando de leitura
enquanto o outro não escreveu ainda.


2) Escreva um programa que primeiro cria
uma FIFO e em seguida cria dois processos
filho que escrevem uma string na FIFO.
O pai dá um waitpid em seguida lê as
strings desse FIFO e exibe na tela


Código:

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <fcntl.h>

int main(int argc, char *argv[])
{
    int fifo_done = mkfifo("ex2_fifo", 0666);

    if (fifo_done < 0)
    {
        perror("erro ao criar fifo");
    }

    int pids[2];
    for (int i = 0; i < 2; i++)
    {
        pids[i] = fork();
        if (pids[i] == 0)
        {
            int fifo = open("ex2_fifo", O_WRONLY);
            if (fifo < 0)
            {
                perror("erro ao abrir fifo");
            }
            char buffer[] = "Eu sou o filho melhor!";
            printf("vou escrever\n");
            write(fifo, buffer, sizeof(buffer));
            printf("ja escrevi\n");
            close(fifo);
            exit(0);
        }
    }

    int fifo = open("ex2_fifo", O_RDONLY);

    int stat_loc = -1;

    waitpid(pids[0], &stat_loc, 0);
    waitpid(pids[1], &stat_loc, 0);

    char buffer[100];

    ssize_t bytes_read = -1;

    bytes_read = read(fifo, buffer, sizeof(buffer));
    printf("Filho disse:\n%s\n", buffer);

    while (bytes_read > 0)
    {
        bytes_read = read(fifo, buffer, sizeof(buffer));
        printf("Filho disse:\n%s\n", buffer);
    }

    close(fifo);
    unlink("ex2_fifo");

    return 0;
}

Comando:
gcc lab5/ex2.c -o build/ex2
./build/ex2


Saída:
vou escrever
ja escrevi
vou escrever
ja escrevi
Filho disse:
Eu sou o filho melhor!
Filho disse:
Eu sou o filho melhor!


Racional:
O pai cria o fifo, dando permissões a todos. Depois, faz dois forks para que os filhos façam seus trabalhos: eles escrevem no fifo uma mensagem e depois morrem.
Entretanto, até que o pai abra o fifo em modo de leitura, os filhos bloqueiam. Depois, os filhos trabalham normalmente e morrem.
Uma situação interessante: cada filho escreve uma mensagem no fifo, e em primeiro lugar, um não sobrescreve o outro.
Até aí tudo bem, é o comportamento do fifo. O mais curioso é que as mensagens dos filhos vieram em dois reads
separados do pai! Aparentemente o kernel decidiu devolver o conteúdo em dois reads, talvez por terem sido feitos por
dois processos diferentes.


3) Escreva um servidor e um cliente usando duas
FIFOs: uma para enviar strings para o servidor,
e outra para transmitir as respostas de volta
para os clientes. O servidor deverá rodar em
background e transformar cada palavra
recebida de minusculas para maiúsculas.
Obs: execute os seus clientes em terminais diferentes. 


Código:
// ex3_servidor.c

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <ctype.h>
#include <sys/stat.h>
#include <fcntl.h>

char *to_upper_str(char *string, int n)
{
    for (int i = 0; i < n; i++)
    {
        string[i] = toupper(string[i]);
    }
}

int main(int argc, char *argv[])
{

    while (1)
    {
        int request = open("cliente_para_servidor", O_RDONLY);
        if (request < 0)
        {
            perror("erro ao abrir fifo");
        }

        printf("Servidor: abri a conexão do pedido!\n");

        ssize_t bytes_read = 0;
        char buffer[100];

        while (bytes_read == 0)
        {
            bytes_read = read(request, buffer, sizeof(buffer));
        }

        close(request);

        printf("Servidor: li o pedido: %s\n", buffer);

        int response = open("servidor_para_cliente", O_WRONLY);
        if (response < 0)
        {
            perror("erro ao abrir fifo");
        }

        printf("Servidor: abri a conexão da resposta!\n");

        to_upper_str(buffer, bytes_read);

        write(response, buffer, sizeof(buffer));
        close(response);

        printf("Servidor: escrevi a resposta!\n");
    }

    return 0;
}


// ex3_cliente.c

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <fcntl.h>

int main(int argc, char *argv[])
{
    for (int i = 0; i < 2; i++)
    {

        int request = open("cliente_para_servidor", O_WRONLY);
        if (request < 0)
        {
            perror("erro ao abrir fifo");
        }
        printf("Cliente: consegui abrir a conexão do pedido!\n");

        char buffer[100] = "oi servidor!";

        write(request, buffer, sizeof(buffer));

        close(request);

        printf("Cliente: consegui enviar o pedido!\n");

        int response = open("servidor_para_cliente", O_RDONLY);
        if (response < 0)
        {
            perror("erro ao abrir fifo");
        }

        printf("Cliente: consegui abrir a conexão da resposta!\n");

        ssize_t bytes_read = 0;

        while (bytes_read == 0)
        {
            bytes_read = read(response, buffer, sizeof(buffer));
        }

        close(response);

        printf("Cliente: servidor respondeu isso: %s\n", buffer);
    }

    return 0;
}


Comando:
mkfifo servidor_para_cliente
mkfifo cliente_para_servidor

gcc lab5/ex3_cliente.c -o build/ex3_cliente
gcc lab5/ex3_servidor.c -o build/ex3_servidor


./build/ex3_servidor &
./build/ex3_cliente

# como pedido pelo exercício, rodar outro cliente em outro terminal:
./build/ex3_cliente

Saída no primeiro terminal:

Cliente: consegui abrir a conexão do pedido!
Cliente: consegui enviar o pedido!
Servidor: li o pedido: oi servidor!
Servidor: abri a conexão da resposta!
Cliente: consegui abrir a conexão da resposta!
Cliente: servidor respondeu isso: OI SERVIDOR!
Servidor: escrevi a resposta!
Servidor: abri a conexão do pedido!
Cliente: consegui abrir a conexão do pedido!
Cliente: consegui enviar o pedido!
Servidor: li o pedido: oi servidor!
Servidor: abri a conexão da resposta!
Cliente: consegui abrir a conexão da resposta!
Servidor: escrevi a resposta!
Cliente: servidor respondeu isso: OI SERVIDOR!
Servidor: abri a conexão do pedido!
Servidor: li o pedido: oi servidor!
Servidor: abri a conexão da resposta!
Servidor: escrevi a resposta!
Servidor: abri a conexão do pedido!
Servidor: li o pedido: oi servidor!
Servidor: abri a conexão da resposta!
Servidor: escrevi a resposta!

Saída no segundo terminal:
Cliente: consegui abrir a conexão do pedido!
Cliente: consegui enviar o pedido!
Cliente: consegui abrir a conexão da resposta!
Cliente: servidor respondeu isso: OI SERVIDOR!
Cliente: consegui abrir a conexão do pedido!
Cliente: consegui enviar o pedido!
Cliente: consegui abrir a conexão da resposta!
Cliente: servidor respondeu isso: OI SERVIDOR!


Racional:

Um sistema de pedido e resposta foi simulado usando a abertura de fifos. O servidor fica esperando, bloqueado,
algum processo que abra o fifo cliente_para_servidor em modo de escrita (esperando um pedido). Enquanto isso, o cliente pode
"iniciar" um pedido abrindo esse fifo. Então, ele tenta ler várias vezes o
fifo, até que algum dado venha (enviado pelo cliente, que escreve o dado no fifo).
Depois de guardar o dado, ele abre o fifo de servidor_para_cliente
em modo escrita, para escrever sua resposta (e o cliente abre o fifo em modo de leitura).
Então, ele calcula o resultado da operação de minúsculas para maiúsculas usando
a função to_upper_str, e depois escreve o resultado no fifo de resposta. Assim, o cliente recebe
a resposta e a exibe.
Esse ciclo é executado 2 vezes para fins de demonstração. Vemos que no primeiro terminal, quando rodamos
o cliente no mesmo terminal que o servidor, ficam
intercaladas as impressões na tela do servidor e do cliente, pois o servidor está em background e coloca suas impressões ali também.
Quando rodamos o cliente em outro terminal, as impressões do servidor aparecem no primeiro terminal, enquanto as do cliente aparecem no
segundo, pois suas respectivas saídas padrão estão em terminais diferentes.