1) Execute o programa “ctrl-c.c”.
Digite Ctrl-C e Ctrl-\. Analise o resultado.
Neste mesmo programa, remova os
comandos signal( ) e repita o teste anterior
observando os resultados.

Código: no enunciado

Comando:
gcc ./lab3/ctrl-c.c -o ./build/ctrl-c
./build/ctrl-c
# depois, teclar ctrl + c 3 vezes, depois ctrl + \

Saída:
Endereco do manipulador anterior (nil)
Endereco do manipulador anterior (nil)
Ctrl-C desabilitado. Use Ctrl-\ para terminar
^CVocê pressionou Ctrl-C (2)
^CVocê pressionou Ctrl-C (2)
^CVocê pressionou Ctrl-C (2)
^\Terminando o processo...

Racional:

Ctrl-C não interrompeu o processo porque o handler não para a execução do programa, só realiza o printf.
Ctrl-\ interrompe o programa, executando o código presente no quitHandler.


Código: mesmo que o anterior, comentando as linhas:
//p = signal(SIGINT, intHandler);
//p = signal(SIGQUIT, quitHandler);

Comando: mesmos do anterior, porém o programa já termina depois do primeiro ctrl-c, sem exibir nada além do "^C" no final.

Saída:
Endereco do manipulador anterior 0x7fff4b194c58
Endereco do manipulador anterior 0x7fff4b194c58
Ctrl-C desabilitado. Use Ctrl-\ para terminar
^C

Racional:
O kernel não foi avisado sobre qual código deve ser executado para lidar com
os sinais em questão, então ele simplesmente executa a ação padrão, que é interromper o processo com o ctrl-c.

2) Tente fazer um programa para interceptar o
sinal SIGKILL. Você conseguiu? Explique.

Código:
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>

void intHandler(int sinal);
void killHandler(int sinal);

int main(void) {
  void (*p)(int); // ponteiro para função que recebe int como
  // parâmetro
  p = signal(SIGINT, intHandler);
  printf("Endereco do manipulador anterior %p\n", p);
  p = signal(SIGKILL, killHandler);
  printf("Endereco do manipulador anterior %p\n", p);
  puts("Ctrl-C desabilitado. Use Ctrl-\\ para terminar");
  for (;;)
    ;
}
void intHandler(int sinal) { printf("Você pressionou Ctrl-C (%d) \n", sinal); }
void killHandler(int sinal) {
  printf("Matando o processo...\n");
  exit(0);
}


Comando:
gcc ./lab3/exc2.c -o ./build/exc2
./build/exc2
# procurar pid do processo com ferramenta externa, no nosso caso, o pid foi 15807. rodar comando a seguir em outro terminal:
kill -s SIGKILL 15807

Saída (no terminal original):
Endereco do manipulador anterior (nil)
Endereco do manipulador anterior 0xffffffffffffffff
Ctrl-C desabilitado. Use Ctrl-\ para terminar
Killed

Racional:
Não foi possível tratar o sinal SIGKILL. O sinal não pode ser ignorado pelo processo, então não é possível desviar o tratamento do sinal
por meio de uma função especificada, e portanto o printf dentro do killHandler não rodou.

3) Execute e explique o funcionamento de
filhocidio.c

Código:

filhocidio.c: presente no slide da aula

filhosleep.c:
#include <unistd.h>

int main() {
  sleep(5);
  return 0;
}

Comando:
gcc ./lab3/filhosleep.c -o ./build/filhosleep
# para ver o fim precoce:
./build/filhocidio 2 ./build/filhosleep
# para ver o processo terminar naturalmente:
./build/filhocidio 15 ./build/filhosleep

Saída o primeiro comando de executar:
Program ./build/filhosleep exceeded limit of 2 seconds!
Child 68673 terminated within 2 seconds com estado 9.

Saída do segundo comando de executar:
Child 68583 terminated within 15 seconds com estado 0.

Racional:
Quando o programa filho demora mais tempo do que o valor especificado pela linha de comando
para o programa pai, o filho recebe o comando de kill enviado pelo pai, pois o pai
termina seu sleep(delay) e continua seu código.
Se o filho termina antes desse sleep(delay) do pai, o pai recebe do kernel um sinal
SIGCHLD, e pode rodar o código de tratamento desse sinal, que, nesse caso, imprime
algumas informações.


4) Usando SIGSTOP e SIGCONT faça um
programa que crie 2 processos filho e alterne a
execução dos filhos. Após 10 trocas de
contexto, o processo pai mata os processos
filho.
OBS: Os processos filho são formados por loops
infinitos.

Código:
// exc5.c
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
  pid_t pid;

  pid_t pids[2] = {-1, -1};

  for (int i = 0; i < 2; i++) {
    if ((pid = fork()) < 0) {
      fprintf(stderr, "Erro ao criar filho\n");
      exit(-1);
    }
    if (pid == 0) { /* child */
      for (;;) {
        ;
      }
    }
    kill(pid, SIGSTOP);
    pids[i] = pid;
  }

  kill(pids[0], SIGSTOP);

  for (int i = 0; i < 5; i++) {
    kill(pids[0], SIGSTOP);
    kill(pids[1], SIGCONT);
    usleep(10000);
    kill(pids[1], SIGSTOP);
    kill(pids[0], SIGCONT);
    usleep(10000);
  }

  kill(pids[0], SIGKILL);
  kill(pids[1], SIGKILL);

  return 0;
}


Comando:
gcc ./lab3/exc4.c -o ./build/exc4
./build/exc4

Saída:
Parando 1 e continuando 2...
Parando 2 e continuando 1...
Parando 1 e continuando 2...
Parando 2 e continuando 1...
Parando 1 e continuando 2...
Parando 2 e continuando 1...
Parando 1 e continuando 2...
Parando 2 e continuando 1...
Parando 1 e continuando 2...
Parando 2 e continuando 1...

5) Faça um programa que leia 2 números e
imprima o resultado das 4 operações básicas
sobre estes 2 números.
- Verifique o que acontece se o 2º. número
da entrada for 0 (zero)
- Capture o sinal de erro de floating point
(SIGFPE) e repita a experiência anterior

Código:
// exc5.c
#include <stdio.h>

int main(void) {
  int num1, num2;
  printf("Digite num1:");
  scanf("%d", &num1);
  printf("Digite num2:");
  scanf("%d", &num2);

  printf("Soma:%d\n", num1 + num2);
  printf("Subtração:%d\n", num1 - num2);
  printf("Multiplicação:%d\n", num1 * num2);
  printf("Divisão:%d\n", num1 / num2);
}

// exc5_parte2.c
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>

void floating_point_exception_handler(int signal);

int main(void) {
  signal(SIGFPE, floating_point_exception_handler);

  int num1, num2;
  printf("Digite num1: ");
  scanf("%d", &num1);
  printf("Digite num2: ");
  scanf("%d", &num2);

  printf("Soma:%d\n", num1 + num2);
  printf("Subtração:%d\n", num1 - num2);
  printf("Multiplicação:%d\n", num1 * num2);
  printf("Divisão:%d\n", num1 / num2);
}

void floating_point_exception_handler(int signal) {
  printf("Ah seu malandro, achou que ia passar 0 pro num2 né? Eu tô "
         "preparado!\n");
  exit(EXIT_FAILURE);
}



Comando:
gcc ./lab3/exc5.c -o ./build/exc5
./build/exc5

gcc ./lab3/exc5_parte2.c -o ./build/exc5_parte2
./build/exc5_parte2


Saída de exc5, uso normal:

Digite num1:3123
Digite num2:32
Soma:3155
Subtração:3091
Multiplicação:99936
Divisão:97

Saída de exc5, passando 0 pra num2:

Digite num1:1345
Digite num2:0
Soma:1345
Subtração:1345
Multiplicação:0
Floating point exception (core dumped)

Saída de exc5_parte2, passando 0 pra num2:

Digite num1: 235
Digite num2: 0
Soma:235
Subtração:235
Multiplicação:0
Ah seu malandro, achou que ia passar 0 pro num2 né? Eu tô preparado!

6) Faça um programa para monitorar e informar o
preço de chamadas telefônicas. O programa
deverá ser executado em background.
- O início e o término de uma chamada são
informados através dos sinais SIGUSR1 e
SIGUSR2, respectivamente.
- O custo da ligação é de 2 centavos por
segundo, para ligações de até 1 minuto ou de 1
centavo por segundo a partir do 2º. minuto, ou
seja, uma ligação de 1m30s custa R$1,50.

Código:

#include <signal.h>
#include <stdio.h>
#include <time.h>
#include <unistd.h>

void usr1_handler(int signal);
void usr2_handler(int signal);

time_t call_beginning = 0;

int main(void) {
  signal(SIGUSR1, usr1_handler);
  signal(SIGUSR2, usr2_handler);

  printf("Hora de monitorar chamadas!\n");
  while (1) {
    pause();
  }
}

void usr1_handler(int signal) { // chamada começou
  time(&call_beginning);
}

void usr2_handler(int signal) { // chamada terminou
  if (call_beginning == 0) {
    printf("Tem que começar chamada pra poder terminar.\n");
  }

  time_t duration = time(NULL) - call_beginning;

  int cents;
  if (duration <= 60) {
    cents = 2 * duration;
  } else {
    cents = 60 * 2 + (duration - 60);
  }

  printf("Sua ligação custou R$%d,%02d\n", cents / 100, cents % 100);
}


Comando:
gcc ./lab3/exc6.c -o ./build/exc6
./build/exc6 &
# ver o PID na saída do terminal. No nosso caso foi 514762
kill -s SIGUSR1 514762
# esperar 6 segundos. O programa também funciona corretamente para valores acima de 1 minuto.
kill -s SIGUSR2 514762


Saída depois do ./build/exc6 &:
[3] 514762

Saída depois do último kill:
Sua ligação custou R$0,12


7) Elabore três programas I/O bound que não
terminem (loop de msgs no vídeo).
- Elabore um programa que seja capaz de
executar os 3 programas indicados anteriormente
e que simule o compartilhamento da CPU entre os
3 processos com escalonamento Round-Robin
com uma fatia de tempo de 1 segundo para o
primeiro processo e de 2 segundos para os
demais processos. Execute os programas e relate
o que aconteceu

Código:
// exc7_pai.c
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <unistd.h>

int main() {
  pid_t pid;

  pid_t pids[3] = {-1, -1, -1};

  for (int i = 0; i < 3; i++) {
    if ((pid = fork()) < 0) {
      fprintf(stderr, "Erro ao criar filho\n");
      exit(-1);
    }
    if (pid == 0) { /* child */
      switch (i) {
      case 0:
        execv("./build/exc7_1", NULL);
        break;
      case 1:
        execv("./build/exc7_2", NULL);
        break;
      case 2:
        execv("./build/exc7_3", NULL);
        break;
      }
    }

    kill(pid, SIGSTOP);
    pids[i] = pid;
  }

  while (1) {
    for (int i = 0; i < 3; i++) {
      short slice_size = 1;
      if (i != 0) {
        slice_size = 2;
      }

      printf("Hora do %d rodar por %d segundos\n", i + 1, slice_size);
      for (int j = 0; j < 3; j++) {
        if (j == i) {
          kill(pids[j], SIGCONT);
        } else {
          kill(pids[j], SIGSTOP);
        }
      }
      sleep(slice_size);
    }
  }

  return 0;
}


// exc7_1.c
#include <stdio.h>
int main(void) {
  while (1) {
    printf("Sou programa 1\n");
  }
}

// exc7_2.c
#include <stdio.h>
int main(void) {
  while (1) {
    printf("Sou programa 2\n");
  }
}

// exc7_3.c
#include <stdio.h>
int main(void) {
  while (1) {
    printf("Sou programa 3\n");
  }
}


Comando:
gcc ./lab3/exc7_1.c -o ./build/exc7_1
gcc ./lab3/exc7_2.c -o ./build/exc7_2
gcc ./lab3/exc7_3.c -o ./build/exc7_3
gcc ./lab3/exc7_pai.c -o ./build/exc7_pai
./build/exc7_pai

Saída:
Sou programa 1
Sou programa 1
Sou programa 1
Sou programa 1
Sou programa 1
Sou programa 1
(... muitas vezes, por 1 segundo ...)
Sou programa 1
Sou programa 1
Sou programa 1
Sou programa 1
Sou programa 1
Sou programa 1
Sou programa 2
Sou programa 2
Sou programa 2
Sou programa 2
Sou programa 2
Sou programa 2
(... muitas vezes, por 2 segundos ...)
Sou programa 2
Sou programa 2
Sou programa 2
Sou programa 2
Sou programa 2
Sou programa 2
Sou programa 3
Sou programa 3
Sou programa 3
Sou programa 3
Sou programa 3
Sou programa 3
(... muitas vezes, por 2 segundos ...)
Sou programa 3
Sou programa 3
Sou programa 3
Sou programa 3
Sou programa 3
Sou programa 3
